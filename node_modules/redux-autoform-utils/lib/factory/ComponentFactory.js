'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _underscore = require('underscore');

var _underscore2 = _interopRequireDefault(_underscore);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// component definitions
var ComponentFactory = function () {
    function ComponentFactory() {
        _classCallCheck(this, ComponentFactory);

        // this is expected to contain a property for each supported type
        // and this property's value is expected to be an array of ComponentBuilder
        this.fieldComponentsByType = {};

        // this is expected to contain a property for each component definition
        // and the value is expected to be the component definition itself
        this.fieldComponentsById = {};

        // defaultFieldComponents is expected to contain a property for each supported type
        // and this property's value is expected to be the component definition id
        this.defaultFieldComponents = {};

        // this is expected to contain a property for each component definition
        // and the value is expected to be the component definition itself
        this.groupComponentsById = {};

        // The id of the default component for groups
        this.defaultGroupComponentId = null;

        // This this a list of Root components
        this.rootComponentsById = {};

        this.currentRoot = null;
    }

    /**
     * Validates the given metadata
     * @param metadata
     */


    _createClass(ComponentFactory, [{
        key: '_validateMetadata',
        value: function _validateMetadata(metadata) {
            if (!metadata) throw "Metadata should not be null or undefined";
            if (!metadata.type) throw "Metadata should have a type";
            if (!metadata.name) throw "Metadata should have a name";
        }

        /**
         * Registers a component definition
         * @param id
         * @param types
         * @param component
         */

    }, {
        key: 'registerFieldComponent',
        value: function registerFieldComponent(id, types, component) {
            // registers the component definition in each given type
            for (var i = 0; i < types.length; i++) {
                var type = types[i];
                if (!(type in this.fieldComponentsByType)) this.fieldComponentsByType[type] = [];
                this.fieldComponentsByType[type].push(component);
            }
            // registers the component definition
            this.fieldComponentsById[id] = component;
        }

        /**
         * @param id The ComponentBuilder id
         */

    }, {
        key: 'getFieldComponent',
        value: function getFieldComponent(id) {
            var component = this.fieldComponentsById[id];
            if (!component) {
                throw 'Could not find the given component. Id: ' + id;
            }
            return this.fieldComponentsById[id];
        }

        /**
         * Returns the current component definitions.
         * If a type is specified, returns the definitions for that type only
         * @returns {{}|*}
         */

    }, {
        key: 'getFieldComponents',
        value: function getFieldComponents(type) {
            if (!type) return this.fieldComponentsByType;
            return this.fieldComponentsByType[type];
        }

        /**
         * Returns the default component definition for the given type
         * @param type
         */

    }, {
        key: 'getDefaultFieldComponent',
        value: function getDefaultFieldComponent(type) {
            if (!type) throw 'type should have a value';
            if (this.defaultFieldComponents[type]) return this.getFieldComponent(this.defaultFieldComponents[type]);
            var componentsForType = this.getFieldComponents(type);
            var component = _underscore2.default.first(componentsForType);
            if (!component) throw new Error('Couldn\'t find any component for the given type. Type: ' + type + '. Make sure the proper component was registered in the ComponentFactory.');
            return component;
        }

        /**
         * Sets the default component per type.
         * @param components - An object that should contain a type as a key and a ComponentBuilder as value
         */

    }, {
        key: 'setDefaultFieldComponents',
        value: function setDefaultFieldComponents(components) {
            this.defaultFieldComponents = components;
        }

        /**
         * Gets the appropriate component based on the given metadata
         * @param fieldComponentProps
         * @returns {*}
         */

    }, {
        key: 'buildFieldComponent',
        value: function buildFieldComponent(fieldComponentProps) {
            if (!fieldComponentProps) throw Error('Argument \'props\' should be truthy');

            this._validateMetadata(fieldComponentProps);
            var componentType = void 0;
            if (fieldComponentProps.component) {
                // if the metadata explicitly specify a component, let's use it
                componentType = this.getFieldComponent(fieldComponentProps.component);
            } else {
                // If the metadata doesn't explicitly specify a component, let's return
                // the default component for type. If there's no default, let's take the first
                // that matches the type
                componentType = this.getDefaultFieldComponent(fieldComponentProps.type);
            }
            if (!componentType) throw new Error('Could not resolve the component for the type. Type: ' + fieldComponentProps.type);

            // if there's a 'reduxFormProps' metadata, it should be merged with the 
            return _react2.default.createElement(componentType, Object.assign({}, fieldComponentProps, fieldComponentProps.reduxFormProps));
        }

        /**
         * Registers a group component
         * @param id
         * @param component
         */

    }, {
        key: 'registerGroupComponent',
        value: function registerGroupComponent(id, component) {
            this.groupComponentsById[id] = component;
        }
    }, {
        key: 'getGroupComponent',
        value: function getGroupComponent(id) {
            var component = this.groupComponentsById[id];
            if (!component) {
                throw Error('Could not resolve the group component. Component: ' + id);
            }
            return component;
        }

        /**
         * Sets the default group component
         * @param id
         */

    }, {
        key: 'setDefaultGroupComponent',
        value: function setDefaultGroupComponent(id) {
            this.defaultGroupComponentId = id;
        }

        /**
         * Gets the default group component
         * @returns {*}
         */

    }, {
        key: 'getDefaultGroupComponent',
        value: function getDefaultGroupComponent() {
            return this.getGroupComponent(this.defaultGroupComponentId);
        }

        /**
         * Gets the appropriate component based on the given metadata
         * @param groupComponentProps
         * @returns {*}
         */

    }, {
        key: 'buildGroupComponent',
        value: function buildGroupComponent(groupComponentProps) {
            if (!groupComponentProps) {
                throw Error('The props parameter is required');
            }

            var componentType = void 0;
            if (groupComponentProps.component) {
                // if the metadata explicitly specify a component, let's use it
                componentType = this.getGroupComponent(groupComponentProps.component);
            } else {
                // If the metadata doesn't explicitly specify a component, let's return
                // the default component for type. If there's no default, let's take the first
                // that matches the type
                componentType = this.getDefaultGroupComponent();
            }
            if (!componentType) throw new Error('Could not resolve the component for the group');

            return _react2.default.createElement(componentType, groupComponentProps);
        }

        // Allows to register a new Root component

    }, {
        key: 'registerRootComponent',
        value: function registerRootComponent(id, component) {
            this.rootComponentsById[id] = component;
        }

        // Allows to define the id of the current Root component that should be used

    }, {
        key: 'setCurrentRoot',
        value: function setCurrentRoot(id) {
            this.currentRoot = id;
        }

        // Return the selected Root component in AutoformInternal

    }, {
        key: 'getRoot',
        value: function getRoot() {
            return this.rootComponentsById[this.currentRoot];
        }
    }]);

    return ComponentFactory;
}();

exports.default = ComponentFactory;
module.exports = exports['default'];